import { Meta, Story, Controls, Canvas, ArgTypes } from '@storybook/blocks';
import * as TableStories from './Table.stories';
import { Table } from './Table';

<Meta of={TableStories} />

# Table Component

The Table component is a powerful, feature-rich data display component built on TanStack Table, offering extensive customization options including sorting, filtering, pagination, tabbed interfaces, column ordering, and column resizing.

## Overview

The Tagaddod Table component provides an intuitive way to display structured data with advanced features such as:

- Column sorting
- Text search and filtering
- Pagination
- Tabbed interfaces
- **Column ordering** with drag and drop
- **Column resizing** with interactive handles
- Customizable row styling
- Export functionality
- Error, loading, and empty states
- RTL language support

This component is ideal for data-heavy applications where users need to view, sort, search, and interact with structured information.

## Import

```jsx
// Basic table import
import { Table } from '@tagaddod/react';

// Cell variants imports
import { 
  Table, 
  QuickColumns, 
  createCellColumn, 
  createInteractiveCellColumn, 
  createActionCellColumn,
  createCustomCellColumn,
  TableCellVariants,
  CellVariantProps 
} from '@tagaddod/react';
```

## Props

<ArgTypes of={Table} />

## Basic Usage

<Canvas of={TableStories.Example} />

```jsx
import { Table } from '@tagaddod/react';
import { IconEdit, IconTrash } from '@tabler/icons-react';
import { Button } from '@tagaddod/react';

// Define column structure
const columns = [
  {
    accessorKey: 'id',
    header: 'ID',
    size: 80,
  },
  {
    accessorKey: 'name',
    header: 'Item',
    size: 250,
  },
  {
    accessorKey: 'stockCollectors',
    header: 'Dispatched to collectors',
    size: 150,
  },
  {
    accessorKey: 'stockWarehouse',
    header: 'Available at warehouse',
    size: 150,
  },
  {
    id: 'actions',
    header: '',
    cell: () => (
      <div style={{ display: 'flex', gap: '8px' }}>
        <Button
          variant="plain"
          size="micro"
          tone="neutral"
          prefixIcon={<IconEdit size={16} />}
          onClick={(e) => {
            e.stopPropagation();
            alert('Edit clicked');
          }}
        />
        <Button
          variant="plain"
          size="micro"
          tone="critical"
          prefixIcon={<IconTrash size={16} />}
          onClick={(e) => {
            e.stopPropagation();
            alert('Delete clicked');
          }}
        />
      </div>
    ),
  },
];

// Sample data
const data = [
  {
    id: 34,
    name: "زيت حلوة 700 مل",
    stockCollectors: 325,
    stockWarehouse: 325,
  },
  // Additional rows...
];

// Render the table
<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  striped={true}
  gridCells={false}
  showHeader={true}
  onRowClick={(row) => console.log('Row clicked:', row.original)}
/>
```

## Interactive Playground

Try out all the Table component features in a single place:

<Canvas of={TableStories.Playground} />

## Column Management Features

The Table component includes advanced column management capabilities that allow users to customize their data view through interactive column ordering and resizing.

<Canvas of={TableStories.ColumnManagement} />

### Column Ordering

Column ordering allows users to reorder table columns by dragging and dropping them. This feature is built using @dnd-kit for modern, accessible drag and drop interactions.

#### Basic Implementation

```jsx
import { Table } from '@tagaddod/react';

const columns = [
  {
    id: 'name',        // Important: Provide unique IDs for all columns
    accessorKey: 'name',
    header: 'Name',
    size: 200,
  },
  {
    id: 'email',
    accessorKey: 'email', 
    header: 'Email',
    size: 250,
  },
  // ... more columns
];

<Table
  data={data}
  columns={columns}
  title="Users Table"
/>
```

#### Key Features

- **Drag Handles**: Hover over column headers to reveal drag handles (⋮⋮⋮)
- **Visual Feedback**: Columns show visual feedback during drag operations
- **Keyboard Accessible**: Use Tab + Arrow keys + Space for reordering
- **Automatic Persistence**: Column order state is maintained during table interactions
- **RTL Support**: Proper handling for right-to-left languages

#### Best Practices

- Always provide unique `id` properties for columns
- Use descriptive column IDs that won't conflict
- Consider disabling column ordering for tables with many interactive cell variants

### Column Resizing  

Column resizing enables users to adjust column widths by dragging resize handles that appear on column borders.

#### Configuration

```jsx
const columns = [
  {
    accessorKey: 'name',
    header: 'Name',
    size: 200,           // Initial width
    minSize: 100,        // Minimum width
    maxSize: 400,        // Maximum width
  },
  {
    accessorKey: 'email',
    header: 'Email', 
    size: 250,
    minSize: 150,
    maxSize: 500,
  },
  {
    accessorKey: 'actions',
    header: 'Actions',
    size: 100,
    enableResizing: false, // Disable resizing for this column
  },
];
```

#### Resize Behavior

- **Interactive Handles**: Resize handles appear on hover at column borders
- **Real-time Updates**: Column widths update immediately during drag
- **Constraints**: Respects `minSize` and `maxSize` boundaries
- **Visual Indicators**: Active resize handles are highlighted
- **Touch Support**: Works on touch devices for mobile compatibility

#### Column Sizing Properties

| Property | Type | Description |
|----------|------|-------------|
| `size` | `number` | Initial column width in pixels |
| `minSize` | `number` | Minimum allowed width (default: 20px) |
| `maxSize` | `number` | Maximum allowed width (default: unlimited) |
| `enableResizing` | `boolean` | Whether column can be resized (default: true) |

#### Advanced Configuration

```jsx
// Global defaults for all columns
const table = useReactTable({
  data,
  columns,
  defaultColumn: {
    size: 150,        // Default width for all columns
    minSize: 50,      // Global minimum width
    maxSize: 500,     // Global maximum width
  },
  enableColumnResizing: true,     // Enable/disable globally
  columnResizeMode: 'onChange',   // Real-time vs onEnd
  columnResizeDirection: 'ltr',   // LTR or RTL
});
```

Use the controls panel below to:
- Toggle features on/off (search, filters, pagination, tabs, etc.)
- Switch between different table states (normal, error, empty, etc.)
- Change direction (LTR/RTL)
- Configure tab behavior
- Modify display options

## Cell Variants

The Table component includes a comprehensive cell variants system that makes it easy to create consistent, interactive table cells. This system provides predefined cell types and helper functions for common use cases.

<Canvas of={TableStories.CellVariants} />

### Available Cell Variants

The table supports 11 predefined cell variants:

1. **Text Single Line** - Basic text display with typography `--t-typography-body-sm-default` and primary text color
2. **Text Multiline** - Multi-line text with first line in primary color, subsequent lines in secondary color
3. **Badge** - Status badges with color tones (default, info, success, warning, critical, magic)
4. **Badge Multiple** - Multiple badges in one cell
5. **Checkbox** - Interactive checkbox for selection
6. **Radio Button** - Radio button group for exclusive selection
7. **Select** - Dropdown selection with options
8. **Text Field** - Editable text input field
9. **Updated Number** - Formatted numbers with proper alignment
10. **Action Icon** - Single action button (typically three dots menu)
11. **Action Dropdown** - Multiple actions in dropdown menu

### Quick Usage with Helper Functions

The easiest way to use cell variants is with the `QuickColumns` helper:

```jsx
import { Table, QuickColumns, createInteractiveCellColumn } from '@tagaddod/react';

const columns = [
  QuickColumns.text('name', 'Customer Name'),
  QuickColumns.badge('status', 'Status'),
  QuickColumns.checkbox('selected', 'Select', (checked, row) => {
    console.log(`Row ${row.id} selected: ${checked}`);
  }),
  QuickColumns.number('amount', 'Amount'),
  QuickColumns.actions('Actions', (row) => {
    console.log('Action clicked for:', row);
  }),
];
```

### Advanced Cell Variant Usage

For more control, use the detailed helper functions:

```jsx
import { 
  createCellColumn, 
  createInteractiveCellColumn, 
  createActionCellColumn 
} from '@tagaddod/react';

const columns = [
  // Text variants
  createCellColumn('customer', 'Customer', 'textSingleLine'),
  createCellColumn('description', 'Description', 'textMultiline'),
  
  // Badge variants
  createCellColumn('status', 'Status', 'badge'),
  createCellColumn('tags', 'Tags', 'badgeMultiple'),
  
  // Interactive variants
  createInteractiveCellColumn('priority', 'Priority', 'select', handlePriorityChange, {
    cellProps: { 
      options: [
        { label: 'High', value: 'high' },
        { label: 'Medium', value: 'medium' },
        { label: 'Low', value: 'low' }
      ]
    }
  }),
  
  createInteractiveCellColumn('approved', 'Approved', 'checkbox', handleApprovalChange),
  
  createInteractiveCellColumn('notes', 'Notes', 'textField', handleNotesChange, {
    cellProps: { placeholder: 'Add notes...' }
  }),
  
  // Action variants
  createActionCellColumn('Actions', 'actionIcon', handleRowAction),
  createActionCellColumn('More', 'actionDropdownIcon', () => {}, {
    actions: [
      { label: 'Edit', onClick: (row) => editRow(row) },
      { label: 'Delete', onClick: (row) => deleteRow(row) },
      { label: 'View Details', onClick: (row) => viewDetails(row) }
    ]
  })
];
```

### Data Structure for Cell Variants

Different cell variants expect specific data structures:

```jsx
const salesData = [
  {
    id: 1,
    customer: 'Olivia Rhye',                                    // textSingleLine
    description: 'Premium customer with\nmultiple orders',      // textMultiline
    status: { text: 'Active', tone: 'success' },               // badge
    tags: [                                                     // badgeMultiple
      { text: 'VIP', tone: 'success' },
      { text: 'Premium', tone: 'info' }
    ],
    selected: true,                                             // checkbox
    priority: 'high',                                           // select/radioButton
    amount: 2400.50,                                            // updatedNumber
    notes: 'Important client'                                   // textField
  }
];
```

### Creating Custom Cell Variants

You can create custom cell variants using the `createCustomCellColumn` helper:

```jsx
import { createCustomCellColumn, CellVariantProps } from '@tagaddod/react';

// Create custom progress bar cell
const ProgressBarCell: React.FC<CellVariantProps<number>> = ({ value }) => (
  <div style={{ 
    width: '100%', 
    height: '8px', 
    backgroundColor: '#eee', 
    borderRadius: '4px',
    overflow: 'hidden'
  }}>
    <div 
      style={{ 
        width: `${value}%`, 
        height: '100%', 
        backgroundColor: '#007bff', 
        transition: 'width 0.3s ease'
      }} 
    />
    <span style={{ fontSize: '12px', marginLeft: '8px' }}>{value}%</span>
  </div>
);

// Use custom cell in column definition
const columns = [
  createCustomCellColumn('progress', 'Progress', ProgressBarCell),
];
```

### Extending the Cell Variants Registry

You can extend the built-in cell variants registry:

```jsx
import { TableCellVariants } from '@tagaddod/react';

// Add your custom variants to the registry
const ExtendedCellVariants = {
  ...TableCellVariants,
  customProgress: ProgressBarCell,
  customRating: RatingStarsCell,
  customChart: MiniChartCell,
};

// Now you can use them with helper functions
const columns = [
  createCellColumn('progress', 'Progress', 'customProgress'),
];
```

### Cell Variant Props Interface

All cell variants implement the `CellVariantProps` interface:

```typescript
interface CellVariantProps<T = any> {
  value: T;                                    // The cell value
  row?: any;                                   // The entire row data
  onChange?: (value: T, row?: any) => void;    // Change handler for interactive cells
  onClick?: (row?: any) => void;               // Click handler for action cells
  options?: Array<{ label: string; value: any }>; // Options for select/radio cells
  className?: string;                          // Additional CSS classes
  [key: string]: any;                         // Additional props
}
```

### RTL Support in Cell Variants

All cell variants automatically support RTL languages with proper:
- Text alignment (right for RTL, left for LTR)
- Font family switching (Arabic fonts for RTL content)
- Line height adjustments (optimized for Arabic text)
- Layout direction (flex-direction, positioning)

The RTL detection and styling is handled automatically by each cell variant component.

### Important Notes for Cell Variants

#### Select Component Requirements
When using Select or ActionDropdown cell variants, ensure that:
- All option values are **non-empty strings**
- Empty string values are automatically filtered out
- Use meaningful values like `'high'`, `'medium'`, `'low'` instead of `''`

```jsx
// ✅ Correct - Non-empty option values
const priorityOptions = [
  { label: 'High', value: 'high' },
  { label: 'Medium', value: 'medium' },
  { label: 'Low', value: 'low' }
];

// ❌ Incorrect - Empty string values will cause errors
const badOptions = [
  { label: 'Select...', value: '' },  // This will be filtered out
  { label: 'High', value: 'high' }
];
```

#### Badge Component Tones
Badge components use `tone` prop with these available values:
- `'default'` - Gray/neutral appearance
- `'info'` - Blue informational tone
- `'success'` - Green success tone  
- `'warning'` - Yellow/orange warning tone
- `'critical'` - Red error/critical tone
- `'magic'` - Purple/gradient special tone

#### Typography Implementation
Text cell variants use consistent typography:
- **Font**: `--t-typography-body-sm-default` for consistent styling
- **Text Single Line**: Primary text color (`--t-color-text-primary`)
- **Text Multiline**: First line uses primary color, subsequent lines use secondary color (`--t-color-text-secondary`)
- **RTL Support**: Automatic line-height adjustments for Arabic text

#### Performance Considerations
For optimal performance with cell variants:
- Use `React.memo` for custom cell components when dealing with large datasets
- Prefer static options arrays over inline object creation
- Consider virtualization for tables with 1000+ rows and complex cell variants

### Troubleshooting Cell Variants

#### Common Issues and Solutions

**"Select.Item must have a value prop that is not an empty string"**
- **Cause**: Select options contain empty string values
- **Solution**: Ensure all option values are non-empty strings or they will be filtered out automatically

**Cell variant not rendering correctly**
- **Cause**: Incorrect data structure passed to cell variant
- **Solution**: Check the expected data structure for each variant in the documentation above

**TypeScript errors with custom cell variants**
- **Cause**: Custom component doesn't implement `CellVariantProps` interface
- **Solution**: Ensure your custom component extends `React.FC<CellVariantProps<YourDataType>>`

**Interactive cells not updating**
- **Cause**: Missing or incorrect `onChange` callback
- **Solution**: Use `createInteractiveCellColumn` and provide proper onChange handler

```jsx
// ✅ Correct interactive cell setup
createInteractiveCellColumn('status', 'Status', 'select', (value, row) => {
  console.log('Status changed:', value, 'for row:', row);
  // Update your data state here
}, {
  cellProps: { 
    options: [
      { label: 'Active', value: 'active' },
      { label: 'Inactive', value: 'inactive' }
    ]
  }
})
```

## Features

### Pagination

Add pagination to control the number of records displayed per page.

```jsx
import { useState } from 'react';

const [pageIndex, setPageIndex] = useState(0);
const [pageSize, setPageSize] = useState(5);

<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  pagination={{
    pageIndex,
    pageSize,
    pageCount: Math.ceil(data.length / pageSize),
    onPageChange: setPageIndex,
    onPageSizeChange: setPageSize,
    pageSizeOptions: [5, 10, 20, 50],
  }}
/>
```

### Enhanced Search and Filters

Enable search functionality and filters for more targeted data exploration.

```jsx
const [searchQuery, setSearchQuery] = useState('');
const [filters, setFilters] = useState({
  status: 'active',
});
const [isFilterBarVisible, setIsFilterBarVisible] = useState(true);

<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  showSearch={true}
  showFilters={true}
  showFilterBar={isFilterBarVisible}
  showExport={true}
  searchQuery={searchQuery}
  onSearchChange={setSearchQuery}
  activeFilters={filters}
  onFilterChange={setFilters}
  onFilterClick={() => setIsFilterBarVisible(!isFilterBarVisible)}
  onExport={() => alert('Export clicked')}
  filterOptions={{
    status: {
      label: 'Status',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Active', value: 'active' },
        { label: 'Inactive', value: 'inactive' },
      ],
    },
    category: {
      label: 'Category',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Food', value: 'food' },
        { label: 'Cleaning', value: 'cleaning' },
        { label: 'Drinks', value: 'drinks' },
      ],
    },
  }}
/>
```

### Table with Tabs

Create tabbed interfaces to organize different data sets.

```jsx
const [activeTab, setActiveTab] = useState('inventory');

<Table
  data={data}
  columns={columns}
  title="Inventory Management"
  showTabs={true}
  tabItems={[
    { id: 'inventory', label: 'Inventory Stock', active: activeTab === 'inventory', badge: productData.length },
    { id: 'orders', label: 'Orders', active: activeTab === 'orders', badge: orderData.length },
  ]}
  onTabChange={(tabId) => {
    setActiveTab(tabId);
    console.log('Tab changed to:', tabId);
  }}
/>
```

### Enhanced Tabs with Automatic Data Switching

For more complex tabbed interfaces, use `tableTabs` to define complete configurations for each tab.

```jsx
<Table
  data={[]} // Default data (not used with tableTabs)
  columns={[]} // Default columns (not used with tableTabs)
  title="Inventory Management"
  showTabs={true}
  tableTabs={[
    {
      id: 'inventory',
      label: 'Inventory Stock',
      active: true, // This tab will be active by default
      badge: productData.length,
      data: productData,
      columns: productColumns,
      title: 'Inventory Stock',
    },
    {
      id: 'orders',
      label: 'Orders',
      badge: orderData.length,
      data: orderData,
      columns: orderColumns,
      title: 'Order History',
    },
  ]}
  onRowClick={(row) => console.log('Row clicked:', row.original)}
/>
```

### Grid Cells

Enable grid cells to show borders between cells for better data visualization.

```jsx
<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  striped={false}
  gridCells={true}
/>
```

### Striped Rows

Use striped rows **only for read-only data** without interactive elements. Striped rows should be avoided when the table contains interactive components like buttons, checkboxes, or form inputs as they can interfere with hover states and user interactions.

```jsx
// ✅ Good - Read-only data display
<Table
  data={readOnlyData}
  columns={displayColumns}
  title="Report Data"
  striped={true}
  onRowClick={undefined} // No row interactions
/>

// ❌ Avoid - Interactive data with form elements
<Table
  data={interactiveData}
  columns={cellVariantColumns}
  title="Editable Data"
  striped={false} // Keep false for better UX
  onRowClick={handleRowClick}
/>
```

## Table States

### Empty State

Show a message when there's no data to display.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="empty"
  emptyMessage="There are no records to display."
/>
```

### Loading State

Display a loading indicator while data is being fetched.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="loading"
/>
```

### Error State

Show an error message when data retrieval fails.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="error"
  errorMessage="Error in data retrieving. Don't worry, it's our fault. Please try again later."
/>
```

### Not Found State

Indicate when a search yields no results.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="notFound"
  notFoundMessage="No available results for 'product XYZ'. Try different item name or ID."
  searchQuery="product XYZ"
/>
```

## Internationalization

The Table component properly handles Right-to-Left (RTL) languages automatically.

```jsx
<div dir="rtl" style={{ width: '100%' }}>
  <Table
    data={data}
    columns={columns}
    title="مخزون المنتجات"
    striped={true}
    gridCells={false}
  />
</div>
```

## Column Configuration

The Table component accepts columns defined according to TanStack Table's `ColumnDef` interface, with additional Tagaddod-specific properties for styling.

```jsx
const columns = [
  // Standard column with accessor and header
  {
    accessorKey: 'id',
    header: 'ID',
    size: 80,
  },
  
  // Column with custom cell rendering
  {
    accessorKey: 'status',
    header: 'Status',
    size: 150,
    cell: info => (
      <span 
        style={{ 
          color: 
            info.getValue() === 'Completed' ? 'var(--t-color-text-success)' :
            info.getValue() === 'Pending' ? 'var(--t-color-text-warning)' :
            'var(--t-color-text-info)'
        }}
      >
        {info.getValue()}
      </span>
    ),
  },
  
  // Column with custom styling via meta
  {
    id: 'actions',
    header: '',
    cell: () => (/* Action buttons */),
    meta: {
      headerClassName: 'custom-header',
      cellClassName: 'custom-cell',
      width: '100px',
    },
  },
];
```

## Advanced Usage

### Controlled Table

Full control of table state for advanced integration needs.

```jsx
const [sorting, setSorting] = useState([]);
const [globalFilter, setGlobalFilter] = useState('');
const [pagination, setPagination] = useState({
  pageIndex: 0,
  pageSize: 10,
});
const [filters, setFilters] = useState({});

<Table
  data={data}
  columns={columns}
  title="Advanced Table"
  searchQuery={globalFilter}
  onSearchChange={setGlobalFilter}
  pagination={{
    pageIndex: pagination.pageIndex,
    pageSize: pagination.pageSize,
    pageCount: Math.ceil(data.length / pagination.pageSize),
    onPageChange: (pageIndex) => setPagination(prev => ({ ...prev, pageIndex })),
    onPageSizeChange: (pageSize) => setPagination(prev => ({ ...prev, pageSize })),
  }}
  defaultSorting={sorting}
  activeFilters={filters}
  onFilterChange={setFilters}
/>
```

### Server-Side Data

For tables with server-side pagination, sorting, and filtering.

```jsx
const [data, setData] = useState([]);
const [totalItems, setTotalItems] = useState(0);
const [loading, setLoading] = useState(false);
const [pagination, setPagination] = useState({
  pageIndex: 0,
  pageSize: 10,
});
const [sorting, setSorting] = useState([]);
const [filters, setFilters] = useState({});

// Fetch data on state changes
useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await api.fetchData({
        page: pagination.pageIndex,
        limit: pagination.pageSize,
        sort: sorting.length > 0 ? { 
          field: sorting[0].id, 
          direction: sorting[0].desc ? 'desc' : 'asc' 
        } : undefined,
        filters,
      });
      
      setData(response.data);
      setTotalItems(response.total);
    } catch (error) {
      console.error('Error fetching data:', error);
    } finally {
      setLoading(false);
    }
  };
  
  fetchData();
}, [pagination, sorting, filters]);

<Table
  data={data}
  columns={columns}
  title="Server-Side Table"
  state={loading ? 'loading' : 'normal'}
  pagination={{
    pageIndex: pagination.pageIndex,
    pageSize: pagination.pageSize,
    pageCount: Math.ceil(totalItems / pagination.pageSize),
    onPageChange: (pageIndex) => setPagination(prev => ({ ...prev, pageIndex })),
    onPageSizeChange: (pageSize) => setPagination(prev => ({ ...prev, pageSize })),
  }}
  defaultSorting={sorting}
  activeFilters={filters}
  onFilterChange={setFilters}
/>
```

## Common Use Cases

### Data Grid with Row Actions

Table with row actions for data management operations.

```jsx
<Table
  data={users}
  columns={[
    { accessorKey: 'name', header: 'Name' },
    { accessorKey: 'email', header: 'Email' },
    { accessorKey: 'role', header: 'Role' },
    {
      id: 'actions',
      header: 'Actions',
      cell: ({ row }) => (
        <div style={{ display: 'flex', gap: '8px' }}>
          <Button
            variant="plain"
            size="micro"
            tone="neutral"
            prefixIcon={<IconEdit size={16} />}
            onClick={(e) => {
              e.stopPropagation();
              editUser(row.original);
            }}
          />
          <Button
            variant="plain"
            size="micro"
            tone="critical"
            prefixIcon={<IconTrash size={16} />}
            onClick={(e) => {
              e.stopPropagation();
              deleteUser(row.original.id);
            }}
          />
        </div>
      ),
    },
  ]}
  onRowClick={(row) => viewUserDetails(row.original.id)}
/>
```

### Dashboard Analytics Table

Display analytical data with metrics and visual indicators.

```jsx
<Table
  data={analyticsData}
  columns={[
    { accessorKey: 'metric', header: 'Metric' },
    { 
      accessorKey: 'value', 
      header: 'Value',
      cell: ({ row }) => formatNumber(row.original.value),
    },
    { 
      accessorKey: 'change', 
      header: 'Change',
      cell: ({ getValue }) => {
        const change = getValue();
        return (
          <div style={{ 
            color: change > 0 ? 'var(--t-color-text-success)' : 'var(--t-color-text-critical)',
            display: 'flex',
            alignItems: 'center',
            gap: '4px'
          }}>
            {change > 0 ? '↑' : '↓'} {Math.abs(change)}%
          </div>
        );
      },
    },
    { 
      id: 'chart',
      header: 'Trend',
      cell: ({ row }) => <SparklineChart data={row.original.trend} />,
    },
  ]}
  title="Performance Metrics"
  gridCells={true}
/>
```

### Record Selection Table

Table with row selection for batch operations.

```jsx
const [selectedRows, setSelectedRows] = useState([]);

// Define selection column
const selectionColumn = {
  id: 'selection',
  header: ({ table }) => (
    <input
      type="checkbox"
      checked={table.getIsAllRowsSelected()}
      onChange={table.getToggleAllRowsSelectedHandler()}
    />
  ),
  cell: ({ row }) => (
    <input
      type="checkbox"
      checked={row.getIsSelected()}
      onChange={row.getToggleSelectedHandler()}
      onClick={(e) => e.stopPropagation()}
    />
  ),
  size: 40,
};

// Columns with selection
const columnsWithSelection = [selectionColumn, ...columns];

<div>
  <div style={{ marginBottom: '16px' }}>
    <Button 
      disabled={selectedRows.length === 0}
      onClick={() => handleBatchAction(selectedRows)}
    >
      Process Selected ({selectedRows.length})
    </Button>
  </div>
  
  <Table
    data={data}
    columns={columnsWithSelection}
    title="Select Records"
    onRowSelectionChange={setSelectedRows}
  />
</div>
```

## Accessibility

The Table component is built with accessibility in mind:

- Semantic HTML table structure (`<table>`, `<thead>`, `<tbody>`, `<tr>`, `<th>`, `<td>`) for optimal screen reader compatibility
- Appropriate ARIA attributes for sorting, filtering, and pagination
- Keyboard navigation support for all interactive elements
- Focus management for row and cell interactions
- Proper contrast ratios for all visual states
- RTL language support with appropriate text alignment and directional changes
- Visible focus indicators for keyboard users
- Responsive design that works on various screen sizes and devices

## Implementation Details

### CSS Variables

The Table component uses the following token CSS variables:

| Variable | Purpose |
|----------|---------|
| `--t-space-*` | Padding and spacing |
| `--t-typography-body-sm-default` | Typography for text cell variants |
| `--t-font-family-primary` | Text font |
| `--t-font-size-*` | Font sizes for text elements |
| `--t-font-weight-*` | Font weights |
| `--t-color-text-primary` | Primary text color |
| `--t-color-text-secondary` | Secondary text color (multiline second lines) |
| `--t-color-text-tertiary` | Tertiary text color |
| `--t-color-border-*` | Border colors |
| `--t-color-surface-primary` | Table background color |
| `--t-color-surface-hover` | Row hover background color |
| `--t-color-surface-active` | Striped row hover background color |
| `--t-color-surface-secondary` | Header background color |
| `--t-color-fill-*` | Highlight colors |
| `--t-border-radius-*` | Border radius |
| `--t-shadow-*` | Box shadows |
| `--t-duration-*` | Animation duration |
| `--t-line-height-*` | Line height for different languages |

### Technical Architecture

The Table component is built on TanStack Table and includes:

- **Data Processing**: Core row model, filtering, sorting, and pagination
- **State Management**: Component-level React state with controlled inputs
- **Event Handling**: Row and cell click handlers
- **Keyboard Navigation**: Accessible keyboard controls
- **Rendering Optimization**: Efficient rendering with React memoization
- **Styling**: CSS Modules with proper scoping
- **Responsive Design**: Mobile-friendly layout and styling

### Performance Considerations

For optimal performance with large datasets:

- Use server-side pagination for tables with more than 1,000 rows
- Implement server-side sorting and filtering for tables with complex data structures
- Consider virtualization for extremely large datasets
- Optimize column rendering by minimizing complex cell renderers
- Use memoization for expensive cell calculations
- Enable the `manualPagination` option for custom data fetching

### Table Integration with Other Components

The Table component seamlessly integrates with other Tagaddod Design System components:

- **Pagination**: For page navigation
- **Tabs**: For tabbed data views
- **Button**: For action buttons
- **TextInput**: For search functionality
- **FilterItem**: For applying data filters
- **Badge**: For count indicators

## Browser Support

The Table component is compatible with all modern browsers:

- Chrome (latest)
- Firefox (latest)
- Safari (latest)
- Edge (latest)
- Mobile browsers (iOS Safari, Android Chrome)

RTL language support works across all supported browsers.

## Dependencies

The Table component's advanced features require these additional dependencies:

### Column Ordering & Resizing
- `@dnd-kit/core` - Modern drag and drop library for React
- `@dnd-kit/sortable` - Sortable utilities for column reordering
- `@dnd-kit/utilities` - Utility functions for drag and drop

These dependencies are automatically included when you install the Table component and provide:
- **Modern DnD**: React 18+ compatible drag and drop
- **Accessibility**: Full keyboard and screen reader support
- **Performance**: Optimized for smooth interactions
- **Touch Support**: Works on mobile and tablet devices

### Bundle Size Impact
The column management features add approximately 15-20KB to your bundle size. If you don't need these features, they can be tree-shaken out in future versions of the component library.
