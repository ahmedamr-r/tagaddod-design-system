import { Meta, Story, Controls, Canvas, ArgTypes } from '@storybook/blocks';
import * as TableStories from './Table.stories';
import { Table } from './Table';

<Meta of={TableStories} />

# Table Component

The Table component is a powerful, feature-rich data display component built on TanStack Table, offering extensive customization options including sorting, filtering, pagination, tabbed interfaces, column ordering, and column resizing.

## Overview

The Tagaddod Table component provides an intuitive way to display structured data with advanced features such as:

- Column sorting
- Text search and filtering
- Pagination
- Tabbed interfaces
- **Column ordering** with drag and drop
- **Column resizing** with interactive handles
- Customizable row styling
- Export functionality
- Error, loading, and empty states
- RTL language support

This component is ideal for data-heavy applications where users need to view, sort, search, and interact with structured information.

## Import

```jsx
// Basic table import
import { Table } from '@tagaddod/react';

// Cell variants imports
import { 
  Table, 
  QuickColumns, 
  createCellColumn, 
  createInteractiveCellColumn, 
  createActionCellColumn,
  createCustomCellColumn,
  TableCellVariants,
  CellVariantProps 
} from '@tagaddod/react';
```

## Props

<ArgTypes of={Table} />

## Basic Usage

<Canvas of={TableStories.Example} />

```jsx
import { Table } from '@tagaddod/react';
import { IconEdit, IconTrash } from '@tabler/icons-react';
import { Button } from '@tagaddod/react';

// Define column structure
const columns = [
  {
    accessorKey: 'id',
    header: 'ID',
    size: 80,
  },
  {
    accessorKey: 'name',
    header: 'Item',
    size: 250,
  },
  {
    accessorKey: 'stockCollectors',
    header: 'Dispatched to collectors',
    size: 150,
  },
  {
    accessorKey: 'stockWarehouse',
    header: 'Available at warehouse',
    size: 150,
  },
  {
    id: 'actions',
    header: '',
    cell: () => (
      <div style={{ display: 'flex', gap: '8px' }}>
        <Button
          variant="plain"
          size="micro"
          tone="neutral"
          prefixIcon={<IconEdit size={16} />}
          onClick={(e) => {
            e.stopPropagation();
            alert('Edit clicked');
          }}
        />
        <Button
          variant="plain"
          size="micro"
          tone="critical"
          prefixIcon={<IconTrash size={16} />}
          onClick={(e) => {
            e.stopPropagation();
            alert('Delete clicked');
          }}
        />
      </div>
    ),
  },
];

// Sample data
const data = [
  {
    id: 34,
    name: "زيت حلوة 700 مل",
    stockCollectors: 325,
    stockWarehouse: 325,
  },
  // Additional rows...
];

// Render the table
<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  striped={true}
  gridCells={false}
  showHeader={true}
  onRowClick={(row) => console.log('Row clicked:', row.original)}
/>
```

## Error Row Highlighting Demo

Demonstration of error row highlighting with the fill-critical-secondary token:

<Canvas of={TableStories.ErrorRowHighlighting} />

## Table Variants

Explore different table configurations through these comprehensive examples:

### Striped Table
<Canvas of={TableStories.StripedTable} />

### Grid Table  
<Canvas of={TableStories.GridTable} />

### Tabbed Table
<Canvas of={TableStories.TabbedTable} />

### Static Table
<Canvas of={TableStories.StaticTable} />


## Column Management Features

The Table component includes advanced column management capabilities that allow users to customize their data view through interactive column ordering and resizing.

### Column Ordering

Column ordering allows users to reorder table columns by dragging and dropping them. This feature is **disabled by default** and must be explicitly enabled via the `enableColumnOrdering` prop. It is built using @dnd-kit for modern, accessible drag and drop interactions.

#### Basic Implementation

```jsx
import { Table } from '@tagaddod/react';

const columns = [
  {
    id: 'name',        // Important: Provide unique IDs for all columns
    accessorKey: 'name',
    header: 'Name',
    size: 200,
  },
  {
    id: 'email',
    accessorKey: 'email', 
    header: 'Email',
    size: 250,
  },
  // ... more columns
];

<Table
  data={data}
  columns={columns}
  title="Users Table"
  enableColumnOrdering={true}  // Enable column ordering
/>
```

#### Key Features

- **Default State**: Column ordering is disabled by default (`enableColumnOrdering={false}`)
- **Drag Handles**: When enabled, hover over column headers to reveal drag handles (⋮⋮⋮)
- **Visual Feedback**: Columns show visual feedback during drag operations
- **Keyboard Accessible**: Use Tab + Arrow keys + Space for reordering
- **Automatic Persistence**: Column order state is maintained during table interactions
- **RTL Support**: Proper handling for right-to-left languages

#### Best Practices

- Always provide unique `id` properties for columns
- Use descriptive column IDs that won't conflict
- Consider disabling column ordering for tables with many interactive cell variants

### Column Resizing  

Column resizing enables users to adjust column widths by dragging resize handles that appear on column borders. This feature is **disabled by default** and must be explicitly enabled via the `enableColumnResizing` prop.

#### Configuration

```jsx
import { Table } from '@tagaddod/react';

const columns = [
  {
    accessorKey: 'name',
    header: 'Name',
    size: 200,           // Initial width
    minSize: 100,        // Minimum width
    maxSize: 400,        // Maximum width
  },
  {
    accessorKey: 'email',
    header: 'Email', 
    size: 250,
    minSize: 150,
    maxSize: 500,
  },
  {
    accessorKey: 'actions',
    header: 'Actions',
    size: 100,
    enableResizing: false, // Disable resizing for this column
  },
];

<Table
  data={data}
  columns={columns}
  title="Resizable Table"
  enableColumnResizing={true}  // Enable column resizing
/>
```

#### Resize Behavior

- **Default State**: Column resizing is disabled by default (`enableColumnResizing={false}`)
- **Interactive Handles**: When enabled, resize handles appear on hover at column borders
- **Real-time Updates**: Column widths update immediately during drag
- **Constraints**: Respects `minSize` and `maxSize` boundaries
- **Visual Indicators**: Active resize handles are highlighted in blue
- **Touch Support**: Works on touch devices for mobile compatibility
- **Double-click**: Double-click resize handles to auto-fit column content

#### Column Sizing Properties

| Property | Type | Description |
|----------|------|-------------|
| `size` | `number` | Initial column width in pixels |
| `minSize` | `number` | Minimum allowed width (default: 20px) |
| `maxSize` | `number` | Maximum allowed width (default: unlimited) |
| `enableResizing` | `boolean` | Whether column can be resized (default: true) |

#### Advanced Configuration

```jsx
// Complete column management setup
<Table
  data={data}
  columns={columns}
  title="Advanced Table"
  enableColumnOrdering={true}     // Enable column ordering
  enableColumnResizing={true}     // Enable column resizing
  gridCells={true}                // Show borders for better visual feedback
  // RTL direction is automatically detected
/>
```

#### Combining Features

```jsx
// Table with both column ordering and resizing
<Table
  data={data}
  columns={columns}
  title="Full Column Management"
  enableColumnOrdering={true}   // Enable column ordering
  enableColumnResizing={true}   // Enable column resizing
  showSearch={true}
  showFilters={true}
  gridCells={true}  // Recommended for better visual feedback
/>
```

#### Column Management Summary

| Feature | Default State | How to Enable |
|---------|---------------|---------------|
| **Column Ordering** | ❌ Disabled | `enableColumnOrdering={true}` |
| **Column Resizing** | ❌ Disabled | `enableColumnResizing={true}` |

**Best Practices:**
- Use `gridCells={true}` when enabling column management features for better visual feedback
- Column ordering works best with unique column IDs
- Both features are disabled by default for better performance
- Consider performance impact with many columns (50+) when enabling both features

Use the controls panel below to:
- Toggle features on/off (search, filters, pagination, tabs, etc.)
- Switch between different table states (normal, error, empty, etc.)
- Change direction (LTR/RTL)
- Configure tab behavior
- Modify display options

## Cell Variants

The Table component includes a comprehensive cell variants system that makes it easy to create consistent, interactive table cells. This system provides predefined cell types and helper functions for common use cases.

<Canvas of={TableStories.CellVariants} />

### How to Create Table Cells

The Table component provides three main approaches for creating table cells, from simple to fully custom:

#### 1. **Quick Columns (Simplest)**
For standard cases, use the `QuickColumns` helper:
```jsx
import { QuickColumns } from '@tagaddod/react';

const columns = [
  QuickColumns.text('name', 'Name'),              // Simple text
  QuickColumns.badge('status', 'Status'),         // Status badges
  QuickColumns.number('amount', 'Amount'),        // Formatted numbers
  QuickColumns.checkbox('selected', 'Select', handleSelection),
  QuickColumns.actions('Actions', handleAction), // Action buttons
];
```

#### 2. **Pre-built Cell Variants (Flexible)**
For more control, use specific cell variant functions:
```jsx
import { createCellColumn, createInteractiveCellColumn } from '@tagaddod/react';

const columns = [
  createCellColumn('description', 'Description', 'textMultiline'),
  createCellColumn('tags', 'Tags', 'badgeMultiple'),
  createInteractiveCellColumn('priority', 'Priority', 'select', handleChange, {
    cellProps: { options: [{ label: 'High', value: 'high' }] }
  }),
];
```

#### 3. **Custom Cell Components (Full Control)**
For unique requirements, create completely custom cells:
```jsx
import { createCustomCellColumn, CellVariantProps } from '@tagaddod/react';

const CustomCell: React.FC<CellVariantProps<any>> = ({ value, row, onChange }) => {
  // Your custom cell implementation with any design system component
  return <YourCustomDesign value={value} />;
};

const columns = [
  createCustomCellColumn('custom', 'Custom', CustomCell),
];
```

### Available Cell Variants

The table supports **13 predefined cell variants** that you can use with `createCellColumn`:

| Variant Type | Cell Variant Name | Description | Data Type |
|--------------|-------------------|-------------|-----------|
| **Text** | `textSingleLine` | Basic text display with RTL support | `string` |
| **Text** | `textMultiline` | Multi-line text with proper line breaks | `string` (with `\n`) |
| **Text** | `textTruncated` | Text with ellipsis and tooltip on overflow | `string` |
| **Text** | `textSingleLineWithBadge` | Text with optional badge and prefix icon | `{text: string, badge?: string, badgeVariant?: string, prefixIcon?: ReactNode}` |
| **Badge** | `badge` | Single status badge with tone | `{text: string, tone?: 'success' \| 'warning' \| ...}` |
| **Badge** | `badgeMultiple` | Multiple badges in one cell | `Array<{text: string, tone?: string}>` |
| **Interactive** | `checkbox` | Interactive checkbox for selection | `boolean` |
| **Interactive** | `radioButton` | Radio button group for exclusive selection | `string` + options |
| **Interactive** | `select` | Dropdown selection with options | `string` + options |
| **Interactive** | `textField` | Editable text input field | `string` |
| **Data** | `updatedNumber` | Formatted numbers with locale support | `number` or `{primary: number, secondary?: number}` |
| **Actions** | `actionIcon` | Single or multiple action buttons | Any (uses onClick callback) |
| **Actions** | `actionDropdownIcon` | Action dropdown menu | `Array<{label: string, onClick: Function}>` |

### Quick Usage with Helper Functions

The easiest way to use cell variants is with the `QuickColumns` helper:

```jsx
import { Table, QuickColumns, createInteractiveCellColumn } from '@tagaddod/react';

const columns = [
  QuickColumns.text('name', 'Customer Name'),
  QuickColumns.badge('status', 'Status'),
  QuickColumns.checkbox('selected', 'Select', (checked, row) => {
    console.log(`Row ${row.id} selected: ${checked}`);
  }),
  QuickColumns.number('amount', 'Amount'),
  QuickColumns.actions('Actions', (row) => {
    console.log('Action clicked for:', row);
  }),
];
```

### Advanced Cell Variant Usage

For more control, use the detailed helper functions:

```jsx
import { 
  createCellColumn, 
  createInteractiveCellColumn, 
  createActionCellColumn 
} from '@tagaddod/react';

const columns = [
  // Text variants
  createCellColumn('customer', 'Customer', 'textSingleLine'),
  createCellColumn('description', 'Description', 'textMultiline'),
  
  // Badge variants
  createCellColumn('status', 'Status', 'badge'),
  createCellColumn('tags', 'Tags', 'badgeMultiple'),
  
  // Interactive variants
  createInteractiveCellColumn('priority', 'Priority', 'select', handlePriorityChange, {
    cellProps: { 
      options: [
        { label: 'High', value: 'high' },
        { label: 'Medium', value: 'medium' },
        { label: 'Low', value: 'low' }
      ]
    }
  }),
  
  createInteractiveCellColumn('approved', 'Approved', 'checkbox', handleApprovalChange),
  
  createInteractiveCellColumn('notes', 'Notes', 'textField', handleNotesChange, {
    cellProps: { placeholder: 'Add notes...' }
  }),
  
  // Action variants
  createActionCellColumn('Actions', 'actionIcon', handleRowAction),
  createActionCellColumn('More', 'actionDropdownIcon', () => {}, {
    actions: [
      { label: 'Edit', onClick: (row) => editRow(row) },
      { label: 'Delete', onClick: (row) => deleteRow(row) },
      { label: 'View Details', onClick: (row) => viewDetails(row) }
    ]
  })
];
```

### Data Structure for Cell Variants

Different cell variants expect specific data structures:

```jsx
const salesData = [
  {
    id: 1,
    customer: 'Olivia Rhye',                                    // textSingleLine
    description: 'Premium customer with\nmultiple orders',      // textMultiline
    status: { text: 'Active', tone: 'success' },               // badge
    tags: [                                                     // badgeMultiple
      { text: 'VIP', tone: 'success' },
      { text: 'Premium', tone: 'info' }
    ],
    selected: true,                                             // checkbox
    priority: 'high',                                           // select/radioButton
    amount: 2400.50,                                            // updatedNumber
    notes: 'Important client'                                   // textField
  }
];
```

### Creating Custom Cell Variants

You can create completely custom cell variants using the `createCustomCellColumn` helper. This gives you full control over the cell's appearance and behavior while maintaining consistency with the table system.

#### Example 1: Progress Bar Cell

```jsx
import { createCustomCellColumn, CellVariantProps } from '@tagaddod/react';

// Create custom progress bar cell
const ProgressBarCell: React.FC<CellVariantProps<number>> = ({ value }) => {
  const isRTL = document.dir === 'rtl' || document.documentElement.dir === 'rtl';
  
  return (
    <div style={{ 
      display: 'flex',
      alignItems: 'center',
      gap: 'var(--t-space-100)',
      width: '100%'
    }}>
      <div style={{ 
        flex: 1,
        height: '8px', 
        backgroundColor: 'var(--t-color-surface-tertiary)', 
        borderRadius: 'var(--t-border-radius-sm)',
        overflow: 'hidden'
      }}>
        <div 
          style={{ 
            width: `${value || 0}%`, 
            height: '100%', 
            backgroundColor: 'var(--t-color-fill-brand-primary)', 
            transition: 'width 0.3s ease'
          }} 
        />
      </div>
      <span style={{ 
        fontSize: 'var(--t-font-size-sm)',
        fontWeight: 'var(--t-font-weight-medium)',
        color: 'var(--t-color-text-secondary)',
        minWidth: '32px',
        textAlign: isRTL ? 'left' : 'right'
      }}>
        {value || 0}%
      </span>
    </div>
  );
};

// Use in column definition
const columns = [
  createCustomCellColumn('completion', 'Progress', ProgressBarCell),
];
```

#### Example 2: User Avatar Cell with Two Lines

```jsx
import { Avatar } from '@tagaddod/react';

interface UserCellData {
  name: string;
  email: string;
  avatar?: string;
}

const UserAvatarCell: React.FC<CellVariantProps<UserCellData>> = ({ value }) => {
  const isRTL = document.dir === 'rtl' || document.documentElement.dir === 'rtl';
  
  const lineHeightStyle = {
    lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
  };
  
  return (
    <div style={{ 
      display: 'flex',
      alignItems: 'center',
      gap: 'var(--t-space-200)'
    }}>
      <Avatar 
        src={value?.avatar} 
        fallback={value?.name?.charAt(0) || '?'}
        size="small"
      />
      <div>
        <div style={{ 
          ...lineHeightStyle,
          font: 'var(--t-typography-body-sm-medium)',
          color: 'var(--t-color-text-primary)'
        }}>
          {value?.name || '-'}
        </div>
        <div style={{ 
          ...lineHeightStyle,
          font: 'var(--t-typography-body-sm-default)',
          color: 'var(--t-color-text-secondary)'
        }}>
          {value?.email || '-'}
        </div>
      </div>
    </div>
  );
};

// Usage with data structure
const userData = [
  {
    id: 1,
    user: {
      name: 'Ahmed Al-Rashid',
      email: 'ahmed@example.com',
      avatar: 'https://example.com/avatar1.jpg'
    },
    role: 'Admin'
  }
];

const columns = [
  createCustomCellColumn('user', 'User', UserAvatarCell),
  QuickColumns.text('role', 'Role'),
];
```

#### Example 3: Interactive Rating Cell

```jsx
import { useState } from 'react';
import { IconStar } from '@tabler/icons-react';

const RatingCell: React.FC<CellVariantProps<number>> = ({ 
  value, 
  onChange, 
  row 
}) => {
  const [hoveredStar, setHoveredStar] = useState<number | null>(null);
  
  const handleStarClick = (rating: number) => {
    onChange?.(rating, row);
  };
  
  return (
    <div style={{ 
      display: 'flex',
      gap: 'var(--t-space-050)'
    }}>
      {[1, 2, 3, 4, 5].map((star) => (
        <IconStar
          key={star}
          size={16}
          style={{
            cursor: 'pointer',
            color: (hoveredStar || value || 0) >= star 
              ? 'var(--t-color-fill-warning-primary)' 
              : 'var(--t-color-border-secondary)',
            fill: (hoveredStar || value || 0) >= star 
              ? 'var(--t-color-fill-warning-primary)' 
              : 'transparent'
          }}
          onClick={() => handleStarClick(star)}
          onMouseEnter={() => setHoveredStar(star)}
          onMouseLeave={() => setHoveredStar(null)}
        />
      ))}
    </div>
  );
};

// Use as interactive cell
const columns = [
  createInteractiveCellColumn('rating', 'Rating', 'custom', handleRatingChange, {
    cellProps: { CustomComponent: RatingCell }
  })
];
```

#### Example 4: Status Cell with Icon and Color

```jsx
import { IconCircleCheck, IconClock, IconAlertTriangle } from '@tabler/icons-react';

interface StatusCellData {
  status: 'completed' | 'pending' | 'failed';
  label: string;
}

const StatusIconCell: React.FC<CellVariantProps<StatusCellData>> = ({ value }) => {
  const isRTL = document.dir === 'rtl' || document.documentElement.dir === 'rtl';
  
  const getStatusConfig = (status: string) => {
    switch (status) {
      case 'completed':
        return {
          icon: <IconCircleCheck size={16} />,
          color: 'var(--t-color-text-success)',
          bgColor: 'var(--t-color-fill-success-secondary)'
        };
      case 'pending':
        return {
          icon: <IconClock size={16} />,
          color: 'var(--t-color-text-warning)',
          bgColor: 'var(--t-color-fill-warning-secondary)'
        };
      case 'failed':
        return {
          icon: <IconAlertTriangle size={16} />,
          color: 'var(--t-color-text-critical)',
          bgColor: 'var(--t-color-fill-critical-secondary)'
        };
      default:
        return {
          icon: <IconClock size={16} />,
          color: 'var(--t-color-text-secondary)',
          bgColor: 'var(--t-color-surface-secondary)'
        };
    }
  };
  
  const config = getStatusConfig(value?.status || '');
  
  return (
    <div style={{ 
      display: 'flex',
      alignItems: 'center',
      gap: 'var(--t-space-100)',
      padding: 'var(--t-space-100) var(--t-space-200)',
      backgroundColor: config.bgColor,
      borderRadius: 'var(--t-border-radius-sm)',
      width: 'fit-content'
    }}>
      <span style={{ color: config.color, display: 'flex' }}>
        {config.icon}
      </span>
      <span style={{ 
        font: 'var(--t-typography-body-sm-medium)',
        color: config.color,
        lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
      }}>
        {value?.label || '-'}
      </span>
    </div>
  );
};

// Usage
const taskData = [
  {
    id: 1,
    task: 'Setup Database',
    status: {
      status: 'completed' as const,
      label: 'Completed'
    }
  }
];

const columns = [
  QuickColumns.text('task', 'Task'),
  createCustomCellColumn('status', 'Status', StatusIconCell),
];
```

### Custom Cells by Importing Other Components

The Table component works seamlessly with other Tagaddod Design System components. Here are examples of creating custom cells by importing and using existing components:

#### Example 5: Dropdown Actions Cell

```jsx
import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem } from '@tagaddod/react';
import { Button } from '@tagaddod/react';
import { IconDots, IconEdit, IconTrash, IconEye } from '@tabler/icons-react';

const DropdownActionsCell: React.FC<CellVariantProps<any>> = ({ row }) => {
  const handleEdit = () => {
    console.log('Edit:', row);
  };
  
  const handleDelete = () => {
    console.log('Delete:', row);
  };
  
  const handleView = () => {
    console.log('View:', row);
  };
  
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="plain"
          size="micro"
          tone="neutral"
          prefixIcon={<IconDots size={16} />}
          onClick={(e) => e.stopPropagation()}
        />
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={handleView}>
          <IconEye size={16} />
          View Details
        </DropdownMenuItem>
        <DropdownMenuItem onClick={handleEdit}>
          <IconEdit size={16} />
          Edit
        </DropdownMenuItem>
        <DropdownMenuItem onClick={handleDelete} destructive>
          <IconTrash size={16} />
          Delete
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

const columns = [
  QuickColumns.text('name', 'Name'),
  createCustomCellColumn('actions', 'Actions', DropdownActionsCell),
];
```

#### Example 6: Toggle Switch Cell

```jsx
import { Switch } from '@tagaddod/react';

const ToggleSwitchCell: React.FC<CellVariantProps<boolean>> = ({ 
  value, 
  onChange, 
  row 
}) => {
  return (
    <Switch
      checked={value || false}
      onCheckedChange={(checked) => onChange?.(checked, row)}
      onClick={(e) => e.stopPropagation()}
    />
  );
};

const columns = [
  QuickColumns.text('feature', 'Feature'),
  createInteractiveCellColumn('enabled', 'Enabled', 'custom', handleToggleChange, {
    cellProps: { CustomComponent: ToggleSwitchCell }
  }),
];
```

#### Example 7: Tag Input Cell

```jsx
import { TagInput } from '@tagaddod/react';

const TagInputCell: React.FC<CellVariantProps<string[]>> = ({ 
  value, 
  onChange, 
  row 
}) => {
  return (
    <TagInput
      value={value || []}
      onValueChange={(tags) => onChange?.(tags, row)}
      placeholder="Add tags..."
      onClick={(e) => e.stopPropagation()}
    />
  );
};

const columns = [
  QuickColumns.text('title', 'Title'),
  createInteractiveCellColumn('tags', 'Tags', 'custom', handleTagsChange, {
    cellProps: { CustomComponent: TagInputCell }
  }),
];
```

#### Example 8: Date Picker Cell

```jsx
import { DatePicker } from '@tagaddod/react';

const DatePickerCell: React.FC<CellVariantProps<Date | null>> = ({ 
  value, 
  onChange, 
  row 
}) => {
  return (
    <DatePicker
      value={value}
      onValueChange={(date) => onChange?.(date, row)}
      onClick={(e) => e.stopPropagation()}
    />
  );
};

const columns = [
  QuickColumns.text('task', 'Task'),
  createInteractiveCellColumn('dueDate', 'Due Date', 'custom', handleDateChange, {
    cellProps: { CustomComponent: DatePickerCell }
  }),
];
```

### Extending the Cell Variants Registry

You can extend the built-in cell variants registry to add your custom variants and use them with the helper functions:

```jsx
import { TableCellVariants } from '@tagaddod/react';

// Add your custom variants to the registry
const ExtendedCellVariants = {
  ...TableCellVariants,
  progressBar: ProgressBarCell,
  userAvatar: UserAvatarCell,
  ratingStars: RatingCell,
  statusIcon: StatusIconCell,
  dropdownActions: DropdownActionsCell,
  toggleSwitch: ToggleSwitchCell,
};

// Now you can use them with helper functions
const columns = [
  createCellColumn('completion', 'Progress', 'progressBar'),
  createCellColumn('user', 'User', 'userAvatar'),
  createInteractiveCellColumn('rating', 'Rating', 'ratingStars', handleRatingChange),
  createCellColumn('status', 'Status', 'statusIcon'),
  createCustomCellColumn('actions', 'Actions', 'dropdownActions'),
];
```

### Custom Cell Best Practices

When creating custom cells, follow these best practices:

#### 1. **RTL Support**
Always include RTL detection and proper styling:
```jsx
const isRTL = document.dir === 'rtl' || document.documentElement.dir === 'rtl';
const lineHeightStyle = {
  lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
};
```

#### 2. **Use Design Tokens**
Always use design system tokens for consistency:
```jsx
// ✅ Good - Using design tokens
color: 'var(--t-color-text-primary)',
padding: 'var(--t-space-200)',
borderRadius: 'var(--t-border-radius-sm)',
font: 'var(--t-typography-body-sm-default)'

// ❌ Bad - Hard-coded values
color: '#333',
padding: '8px',
borderRadius: '4px',
font: '14px sans-serif'
```

#### 3. **Handle Click Events Properly**
Prevent event bubbling for interactive elements:
```jsx
<Button
  onClick={(e) => {
    e.stopPropagation(); // Prevent row click when button is clicked
    handleAction();
  }}
/>
```

#### 4. **Data Type Safety**
Define proper TypeScript interfaces for complex data:
```jsx
interface CustomCellData {
  primary: string;
  secondary?: string;
  metadata?: Record<string, any>;
}

const CustomCell: React.FC<CellVariantProps<CustomCellData>> = ({ value }) => {
  // Type-safe access to value properties
  return <div>{value?.primary || '-'}</div>;
};
```

#### 5. **Performance Optimization**
Use React.memo for complex cells with large datasets:
```jsx
import { memo } from 'react';

const ExpensiveCustomCell: React.FC<CellVariantProps<ComplexData>> = memo(({ value }) => {
  // Complex rendering logic
  return <div>...</div>;
});
```

### Cell Variant Props Interface

All cell variants implement the `CellVariantProps` interface:

```typescript
interface CellVariantProps<T = any> {
  value: T;                                    // The cell value
  row?: any;                                   // The entire row data
  onChange?: (value: T, row?: any) => void;    // Change handler for interactive cells
  onClick?: (row?: any) => void;               // Click handler for action cells
  options?: Array<{ label: string; value: any }>; // Options for select/radio cells
  className?: string;                          // Additional CSS classes
  [key: string]: any;                         // Additional props
}
```

### RTL Support in Cell Variants

All cell variants automatically support RTL languages with proper:
- Text alignment (right for RTL, left for LTR)
- Font family switching (Arabic fonts for RTL content)
- Line height adjustments (optimized for Arabic text)
- Layout direction (flex-direction, positioning)

The RTL detection and styling is handled automatically by each cell variant component.

### Important Notes for Cell Variants

#### Select Component Requirements
When using Select or ActionDropdown cell variants, ensure that:
- All option values are **non-empty strings**
- Empty string values are automatically filtered out
- Use meaningful values like `'high'`, `'medium'`, `'low'` instead of `''`

```jsx
// ✅ Correct - Non-empty option values
const priorityOptions = [
  { label: 'High', value: 'high' },
  { label: 'Medium', value: 'medium' },
  { label: 'Low', value: 'low' }
];

// ❌ Incorrect - Empty string values will cause errors
const badOptions = [
  { label: 'Select...', value: '' },  // This will be filtered out
  { label: 'High', value: 'high' }
];
```

#### Badge Component Tones
Badge components use `tone` prop with these available values:
- `'default'` - Gray/neutral appearance
- `'info'` - Blue informational tone
- `'success'` - Green success tone  
- `'warning'` - Yellow/orange warning tone
- `'critical'` - Red error/critical tone
- `'magic'` - Purple/gradient special tone

#### Typography Implementation
Text cell variants use consistent typography:
- **Font**: `--t-typography-body-sm-default` for consistent styling
- **Text Single Line**: Primary text color (`--t-color-text-primary`)
- **Text Multiline**: First line uses primary color, subsequent lines use secondary color (`--t-color-text-secondary`)
- **RTL Support**: Automatic line-height adjustments for Arabic text

#### Performance Considerations
For optimal performance with cell variants:
- Use `React.memo` for custom cell components when dealing with large datasets
- Prefer static options arrays over inline object creation
- Consider virtualization for tables with 1000+ rows and complex cell variants

### Troubleshooting Cell Variants

#### Common Issues and Solutions

**"Select.Item must have a value prop that is not an empty string"**
- **Cause**: Select options contain empty string values
- **Solution**: Ensure all option values are non-empty strings or they will be filtered out automatically

**Cell variant not rendering correctly**
- **Cause**: Incorrect data structure passed to cell variant
- **Solution**: Check the expected data structure for each variant in the documentation above

**TypeScript errors with custom cell variants**
- **Cause**: Custom component doesn't implement `CellVariantProps` interface
- **Solution**: Ensure your custom component extends `React.FC<CellVariantProps<YourDataType>>`

**Interactive cells not updating**
- **Cause**: Missing or incorrect `onChange` callback
- **Solution**: Use `createInteractiveCellColumn` and provide proper onChange handler

```jsx
// ✅ Correct interactive cell setup
createInteractiveCellColumn('status', 'Status', 'select', (value, row) => {
  console.log('Status changed:', value, 'for row:', row);
  // Update your data state here
}, {
  cellProps: { 
    options: [
      { label: 'Active', value: 'active' },
      { label: 'Inactive', value: 'inactive' }
    ]
  }
})
```

## Custom Cell Development Summary

The Table component's cell variant system provides multiple levels of customization:

### Choose Your Approach

| Approach | Best For | Complexity | Flexibility |
|----------|----------|------------|-------------|
| **QuickColumns** | Standard data types (text, numbers, badges) | Low | Low |
| **Cell Variants** | Common interactive patterns | Medium | Medium |
| **Custom Cells** | Unique designs, complex interactions | High | High |
| **Component Import** | Using existing design system components | Medium | High |

### Quick Reference Guide

```jsx
// 1. Simple text and numbers
QuickColumns.text('name', 'Name')
QuickColumns.number('amount', 'Amount')

// 2. Interactive elements
QuickColumns.checkbox('selected', 'Select', handleChange)
QuickColumns.actions('Actions', handleClick)

// 3. Custom styling with variants
createCellColumn('status', 'Status', 'badge')
createCellColumn('description', 'Description', 'textMultiline')

// 4. Interactive variants with options
createInteractiveCellColumn('priority', 'Priority', 'select', handleChange, {
  cellProps: { options: [...] }
})

// 5. Fully custom cells
const CustomCell = ({ value, row, onChange }) => (
  <YourCustomComponent value={value} onChange={onChange} />
);
createCustomCellColumn('custom', 'Custom', CustomCell)

// 6. Using other design system components
const ComponentCell = ({ value, onChange, row }) => (
  <Switch checked={value} onCheckedChange={(v) => onChange(v, row)} />
);
createCustomCellColumn('toggle', 'Toggle', ComponentCell)
```

### Data Structure Patterns

```jsx
// Text variants
name: "Ahmed Al-Rashid"                    // textSingleLine
description: "Line 1\nLine 2\nLine 3"     // textMultiline

// Badge variants  
status: { text: "Active", tone: "success" }              // badge
tags: [{ text: "VIP", tone: "success" }, {...}]         // badgeMultiple

// Complex text with badge
user: { 
  text: "Ahmed", 
  badge: "VIP", 
  badgeVariant: "success",
  prefixIcon: <IconUser />
}                                          // textSingleLineWithBadge

// Numbers
amount: 1250.50                            // updatedNumber (simple)
counts: { primary: 100, secondary: 50 }   // updatedNumber (complex)

// Interactive
selected: true                             // checkbox
priority: "high"                          // select, radioButton
notes: "Custom text"                      // textField
```

The Table component's cell system is designed to be both powerful and approachable, allowing you to start simple and add complexity only when needed. Whether you're displaying basic data or creating complex interactive experiences, the cell variant system provides the tools and patterns to build consistent, accessible, and performant table interfaces.

## Features

### Pagination

Add pagination to control the number of records displayed per page.

```jsx
import { useState } from 'react';

const [pageIndex, setPageIndex] = useState(0);
const [pageSize, setPageSize] = useState(5);

<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  pagination={{
    pageIndex,
    pageSize,
    pageCount: Math.ceil(data.length / pageSize),
    onPageChange: setPageIndex,
    onPageSizeChange: setPageSize,
    pageSizeOptions: [5, 10, 20, 50],
  }}
/>
```

### Enhanced Search and Filters

Enable search functionality and filters for more targeted data exploration.

```jsx
const [searchQuery, setSearchQuery] = useState('');
const [filters, setFilters] = useState({
  status: 'active',
});
const [isFilterBarVisible, setIsFilterBarVisible] = useState(true);

<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  showSearch={true}
  showFilters={true}
  showFilterBar={isFilterBarVisible}
  showExport={true}
  searchQuery={searchQuery}
  onSearchChange={setSearchQuery}
  activeFilters={filters}
  onFilterChange={setFilters}
  onFilterClick={() => setIsFilterBarVisible(!isFilterBarVisible)}
  onExport={() => alert('Export clicked')}
  filterOptions={{
    status: {
      label: 'Status',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Active', value: 'active' },
        { label: 'Inactive', value: 'inactive' },
      ],
    },
    category: {
      label: 'Category',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Food', value: 'food' },
        { label: 'Cleaning', value: 'cleaning' },
        { label: 'Drinks', value: 'drinks' },
      ],
    },
  }}
/>
```

## Complete Filtering Implementation Guide

### Important: Data Filtering Logic Required

**⚠️ Critical Understanding**: The Table component handles the filter UI (dropdowns, search bar, filter chips) but **does not automatically filter your data**. You must implement the data filtering logic yourself and pass the filtered data to the Table component.

### Step-by-Step Filtering Implementation

Here's a complete example showing how to implement filtering correctly:

```jsx
import { useState, useMemo } from 'react';
import { Table, QuickColumns } from '@tagaddod/react';

function ProductTable() {
  // 1. Raw data (unfiltered)
  const rawData = [
    { id: 1, name: 'Coffee Beans', status: { text: 'Active', value: 'active' }, category: 'food', price: 25.99 },
    { id: 2, name: 'Dish Soap', status: { text: 'Inactive', value: 'inactive' }, category: 'cleaning', price: 3.99 },
    { id: 3, name: 'Orange Juice', status: { text: 'Active', value: 'active' }, category: 'drinks', price: 4.50 },
  ];

  // 2. Filter state
  const [searchQuery, setSearchQuery] = useState('');
  const [filters, setFilters] = useState({});

  // 3. Data filtering function
  const filterData = (data, searchQuery, filters) => {
    let filtered = [...data];

    // Apply search filter
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(item => 
        item.name.toLowerCase().includes(query) ||
        item.id.toString().includes(query)
      );
    }

    // Apply status filter
    if (filters.status && filters.status !== 'all') {
      filtered = filtered.filter(item => item.status.value === filters.status);
    }

    // Apply category filter
    if (filters.category && filters.category !== 'all') {
      filtered = filtered.filter(item => item.category === filters.category);
    }

    return filtered;
  };

  // 4. Get filtered data using useMemo for performance
  const filteredData = useMemo(() => 
    filterData(rawData, searchQuery, filters), 
    [rawData, searchQuery, filters]
  );

  // 5. Filter options configuration
  const filterOptions = {
    status: {
      label: 'Status',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Active', value: 'active' },
        { label: 'Inactive', value: 'inactive' },
      ],
    },
    category: {
      label: 'Category',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Food', value: 'food' },
        { label: 'Cleaning', value: 'cleaning' },
        { label: 'Drinks', value: 'drinks' },
      ],
    },
  };

  const columns = [
    QuickColumns.text('id', 'ID'),
    QuickColumns.text('name', 'Product Name'),
    { 
      accessorKey: 'status',
      header: 'Status',
      cell: ({ getValue }) => getValue().text 
    },
    QuickColumns.text('category', 'Category'),
    { 
      accessorKey: 'price',
      header: 'Price',
      cell: ({ getValue }) => `$${getValue()}` 
    },
  ];

  // 6. Pass filtered data to Table component
  return (
    <Table
      data={filteredData}  // ← Important: Use filtered data, not raw data
      columns={columns}
      title="Product Inventory"
      showSearch={true}
      searchQuery={searchQuery}
      onSearchChange={setSearchQuery}
      showFilters={true}
      showFilterBar={true}
      activeFilters={filters}
      onFilterChange={setFilters}
      filterOptions={filterOptions}
    />
  );
}
```

### Key Implementation Points

#### 1. **Separate Data from UI**
```jsx
// ✅ Correct: Filter data before passing to Table
const filteredData = filterData(rawData, searchQuery, filters);
<Table data={filteredData} ... />

// ❌ Incorrect: Passing raw data without filtering
<Table data={rawData} ... />
```

#### 2. **Use useMemo for Performance**
```jsx
// ✅ Correct: Memoize filtered data to prevent unnecessary recalculations
const filteredData = useMemo(() => 
  filterData(rawData, searchQuery, filters), 
  [rawData, searchQuery, filters]
);
```

#### 3. **Handle All Filter Types**
Your filter function must handle both search queries and active filters:
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  // Search filtering
  if (searchQuery.trim()) {
    // Apply search logic
  }

  // Individual filter processing
  Object.keys(filters).forEach(filterKey => {
    if (filters[filterKey] && filters[filterKey] !== 'all') {
      // Apply specific filter logic
    }
  });

  return filtered;
};
```

## Data Processing for Filters

### Understanding Filter Data Flow

```
Raw Data → Search Filter → Category Filters → Filtered Data → Table Component
```

The Table component receives the final filtered data and handles:
- ✅ Displaying filtered results
- ✅ Pagination of filtered data
- ✅ Filter UI (dropdowns, search bar)
- ✅ Filter state management

You handle:
- ✅ Data filtering logic
- ✅ Search implementation
- ✅ Filter value mapping
- ✅ Performance optimization

### Common Data Structures and Filtering Patterns

#### Pattern 1: Simple String/Number Filtering
```jsx
// Data structure
const data = [
  { id: 1, name: 'Product A', category: 'electronics', active: true },
  { id: 2, name: 'Product B', category: 'books', active: false },
];

// Filter function
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query) ||
      item.id.toString().includes(query)
    );
  }

  if (filters.category && filters.category !== 'all') {
    filtered = filtered.filter(item => item.category === filters.category);
  }

  if (filters.status && filters.status !== 'all') {
    const isActive = filters.status === 'active';
    filtered = filtered.filter(item => item.active === isActive);
  }

  return filtered;
};
```

#### Pattern 2: Object-Based Data Filtering
```jsx
// Data structure with object properties
const data = [
  { 
    id: 1, 
    name: 'User A', 
    status: { text: 'Active', value: 'active' },
    role: { text: 'Admin', value: 'admin' }
  }
];

// Filter function with object property access
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query)
    );
  }

  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(item => item.status.value === filters.status);
  }

  if (filters.role && filters.role !== 'all') {
    filtered = filtered.filter(item => item.role.value === filters.role);
  }

  return filtered;
};
```

#### Pattern 3: Date Range Filtering
```jsx
// Data with dates
const data = [
  { id: 1, name: 'Order A', createdDate: '2024-01-15', amount: 100 },
  { id: 2, name: 'Order B', createdDate: '2024-01-20', amount: 250 },
];

// Filter function with date handling
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query)
    );
  }

  // Date range filtering
  if (filters.dateRange && filters.dateRange !== 'all') {
    const now = new Date();
    let startDate;

    switch (filters.dateRange) {
      case 'last7days':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'last30days':
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      default:
        startDate = null;
    }

    if (startDate) {
      filtered = filtered.filter(item => 
        new Date(item.createdDate) >= startDate
      );
    }
  }

  // Amount range filtering
  if (filters.amountRange && filters.amountRange !== 'all') {
    switch (filters.amountRange) {
      case 'under100':
        filtered = filtered.filter(item => item.amount < 100);
        break;
      case '100to500':
        filtered = filtered.filter(item => item.amount >= 100 && item.amount <= 500);
        break;
      case 'over500':
        filtered = filtered.filter(item => item.amount > 500);
        break;
    }
  }

  return filtered;
};
```

## Filter Value Mapping

### The Most Common Filtering Issue

**Problem**: Filter option values don't match data structure values.

#### Example Issue
```jsx
// Filter options use lowercase values
const filterOptions = {
  status: {
    options: [
      { label: 'Active', value: 'active' },    // ← lowercase
      { label: 'Inactive', value: 'inactive' } // ← lowercase
    ]
  }
};

// But data uses object with text property
const data = [
  { status: { text: 'Active', tone: 'success' } },  // ← 'Active' not 'active'
  { status: { text: 'Inactive', tone: 'warning' } } // ← 'Inactive' not 'inactive'
];

// ❌ This won't work:
filtered = filtered.filter(item => item.status.value === filters.status);
// item.status.value is undefined!

// ❌ This won't work either:
filtered = filtered.filter(item => item.status.text === filters.status);
// 'Active' !== 'active'
```

#### Solution: Value Mapping
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (filters.status && filters.status !== 'all') {
    // Create mapping from filter values to data values
    const statusMap = {
      'active': 'Active',     // filter value → data value
      'inactive': 'Inactive'  // filter value → data value
    };
    
    const expectedStatusText = statusMap[filters.status];
    filtered = filtered.filter(item => item.status.text === expectedStatusText);
  }

  return filtered;
};
```

#### Advanced Value Mapping with Locale Support
```jsx
const filterData = (data, searchQuery, filters, locale = 'en') => {
  let filtered = [...data];

  if (filters.status && filters.status !== 'all') {
    // Locale-aware mapping
    const statusMap = {
      'active': locale === 'ar' ? 'نشط' : 'Active',
      'inactive': locale === 'ar' ? 'غير نشط' : 'Inactive'
    };
    
    const expectedStatusText = statusMap[filters.status];
    filtered = filtered.filter(item => item.status.text === expectedStatusText);
  }

  return filtered;
};
```

### Multiple Data Structure Patterns

#### Pattern A: Direct String Comparison
```jsx
// Data: { category: 'electronics' }
// Filter: { category: 'electronics' }
// Solution: Direct comparison
filtered = filtered.filter(item => item.category === filters.category);
```

#### Pattern B: Object with Value Property
```jsx
// Data: { status: { text: 'Active', value: 'active' } }
// Filter: { status: 'active' }
// Solution: Compare with value property
filtered = filtered.filter(item => item.status.value === filters.status);
```

#### Pattern C: Object with Text Property (Mapping Required)
```jsx
// Data: { status: { text: 'Active', tone: 'success' } }
// Filter: { status: 'active' }
// Solution: Map filter value to text value
const statusMap = { 'active': 'Active', 'inactive': 'Inactive' };
const expectedText = statusMap[filters.status];
filtered = filtered.filter(item => item.status.text === expectedText);
```

#### Pattern D: Array Contains Filtering
```jsx
// Data: { tags: ['urgent', 'customer', 'priority'] }
// Filter: { tag: 'urgent' }
// Solution: Array includes check
filtered = filtered.filter(item => item.tags.includes(filters.tag));
```

## Common Filtering Patterns

### 1. Search + Multiple Filters
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  // Step 1: Apply search filter first
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      // Search across multiple fields
      item.name.toLowerCase().includes(query) ||
      item.description.toLowerCase().includes(query) ||
      item.id.toString().includes(query) ||
      item.email.toLowerCase().includes(query)
    );
  }

  // Step 2: Apply each filter
  Object.keys(filters).forEach(filterKey => {
    const filterValue = filters[filterKey];
    
    if (filterValue && filterValue !== 'all') {
      switch (filterKey) {
        case 'status':
          filtered = filtered.filter(item => item.status.value === filterValue);
          break;
        case 'department':
          filtered = filtered.filter(item => item.department === filterValue);
          break;
        case 'role':
          filtered = filtered.filter(item => item.role.value === filterValue);
          break;
        // Add more filter cases as needed
      }
    }
  });

  return filtered;
};
```

### 2. Hierarchical/Nested Filtering
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  // Search in nested properties
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.user.name.toLowerCase().includes(query) ||
      item.user.email.toLowerCase().includes(query) ||
      item.company.name.toLowerCase().includes(query) ||
      item.project.title.toLowerCase().includes(query)
    );
  }

  // Filter nested object properties
  if (filters.userStatus && filters.userStatus !== 'all') {
    filtered = filtered.filter(item => item.user.status === filters.userStatus);
  }

  if (filters.companyType && filters.companyType !== 'all') {
    filtered = filtered.filter(item => item.company.type === filters.companyType);
  }

  return filtered;
};
```

### 3. Numeric Range Filtering
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    // ... search logic
  }

  // Price range filtering
  if (filters.priceRange && filters.priceRange !== 'all') {
    switch (filters.priceRange) {
      case 'under50':
        filtered = filtered.filter(item => item.price < 50);
        break;
      case '50to100':
        filtered = filtered.filter(item => item.price >= 50 && item.price <= 100);
        break;
      case 'over100':
        filtered = filtered.filter(item => item.price > 100);
        break;
    }
  }

  // Quantity filtering
  if (filters.quantity && filters.quantity !== 'all') {
    const [min, max] = filters.quantity.split('-').map(Number);
    filtered = filtered.filter(item => 
      item.quantity >= min && (max ? item.quantity <= max : true)
    );
  }

  return filtered;
};
```

### 4. Date-Based Filtering
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    // ... search logic
  }

  // Date range filtering
  if (filters.dateRange && filters.dateRange !== 'all') {
    const now = new Date();
    let filterDate;

    switch (filters.dateRange) {
      case 'today':
        filterDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        filtered = filtered.filter(item => 
          new Date(item.createdAt) >= filterDate
        );
        break;
      case 'thisWeek':
        filterDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        filtered = filtered.filter(item => 
          new Date(item.createdAt) >= filterDate
        );
        break;
      case 'thisMonth':
        filterDate = new Date(now.getFullYear(), now.getMonth(), 1);
        filtered = filtered.filter(item => 
          new Date(item.createdAt) >= filterDate
        );
        break;
    }
  }

  // Status with overdue logic
  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(item => {
      if (filters.status === 'overdue') {
        return new Date(item.dueDate) < now && item.status !== 'completed';
      }
      return item.status === filters.status;
    });
  }

  return filtered;
};
```

### 5. Performance-Optimized Filtering for Large Datasets
```jsx
import { useMemo, useCallback } from 'react';

const filterData = useCallback((data, searchQuery, filters) => {
  // Early return for no filters
  if (!searchQuery.trim() && Object.keys(filters).length === 0) {
    return data;
  }

  let filtered = data; // Don't spread large arrays unnecessarily

  // Apply most selective filters first
  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(item => item.status.value === filters.status);
  }

  if (filters.category && filters.category !== 'all') {
    filtered = filtered.filter(item => item.category === filters.category);
  }

  // Apply search last (usually least selective)
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query) ||
      item.id.toString().includes(query)
    );
  }

  return filtered;
}, []);

// In component
const filteredData = useMemo(() => 
  filterData(rawData, searchQuery, filters), 
  [rawData, searchQuery, filters, filterData]
);
```

### Table with Tabs

Create tabbed interfaces to organize different data sets.

```jsx
const [activeTab, setActiveTab] = useState('inventory');

<Table
  data={data}
  columns={columns}
  title="Inventory Management"
  showTabs={true}
  tabItems={[
    { id: 'inventory', label: 'Inventory Stock', active: activeTab === 'inventory', badge: productData.length },
    { id: 'orders', label: 'Orders', active: activeTab === 'orders', badge: orderData.length },
  ]}
  onTabChange={(tabId) => {
    setActiveTab(tabId);
    console.log('Tab changed to:', tabId);
  }}
/>
```

### Enhanced Tabs with Automatic Data Switching

For more complex tabbed interfaces, use `tableTabs` to define complete configurations for each tab.

```jsx
<Table
  data={[]} // Default data (not used with tableTabs)
  columns={[]} // Default columns (not used with tableTabs)
  title="Inventory Management"
  showTabs={true}
  tableTabs={[
    {
      id: 'inventory',
      label: 'Inventory Stock',
      active: true, // This tab will be active by default
      badge: productData.length,
      data: productData,
      columns: productColumns,
      title: 'Inventory Stock',
    },
    {
      id: 'orders',
      label: 'Orders',
      badge: orderData.length,
      data: orderData,
      columns: orderColumns,
      title: 'Order History',
    },
  ]}
  onRowClick={(row) => console.log('Row clicked:', row.original)}
/>
```

### Grid Cells

Enable grid cells to show borders between cells for better data visualization.

```jsx
<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  striped={false}
  gridCells={true}
/>
```

### Striped Rows

Use striped rows **only for read-only data** without interactive elements. Striped rows should be avoided when the table contains interactive components like buttons, checkboxes, or form inputs as they can interfere with hover states and user interactions.

```jsx
// ✅ Good - Read-only data display
<Table
  data={readOnlyData}
  columns={displayColumns}
  title="Report Data"
  striped={true}
  onRowClick={undefined} // No row interactions
/>

// ❌ Avoid - Interactive data with form elements
<Table
  data={interactiveData}
  columns={cellVariantColumns}
  title="Editable Data"
  striped={false} // Keep false for better UX
  onRowClick={handleRowClick}
/>
```

### Static Tables (No Hover Effects)

For purely static data displays like reports or dashboards where user interaction is not needed, you can disable row hover effects using the `disableRowHover` prop.

```jsx
// ✅ Static table - perfect for reports and read-only displays
<Table
  data={reportData}
  columns={reportColumns}
  title="Monthly Report"
  striped={true}
  disableRowHover={true}
  showSearch={false}
  showFilters={false}
  showPagination={false}
/>
```

**When to use `disableRowHover`:**
- Static data reports that won't be modified
- Dashboard summary tables
- Print-friendly table layouts
- Performance-critical displays with many rows
- Tables embedded in cards or confined spaces

## Table States

### Empty State

Show a message when there's no data to display.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="empty"
  emptyMessage="There are no records to display."
/>
```

### Loading State

Display a loading indicator while data is being fetched.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="loading"
/>
```

### Error State

Show an error message when data retrieval fails.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="error"
  errorMessage="Error in data retrieving. Don't worry, it's our fault. Please try again later."
/>
```

### Not Found State

Indicate when a search yields no results. The not found state features a title/subtitle structure with customizable messages.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="notFound"
  notFoundMessage="No available results for 'searched item'"
  notFoundSubtitle="Try using different search terms or check your spelling"
  searchQuery="searched item"
/>
```

**Not Found State Features:**
- **Icon**: Uses `IconSearchOff` with 32px size in a 72px circular background
- **Title**: Uses `body-lg-semibold` typography with primary text color
- **Subtitle**: Uses `body-md-default` typography with secondary text color
- **Customizable**: Both title and subtitle messages can be customized
- **Defaults**: Provides sensible default messages if not specified

## Internationalization

The Table component properly handles Right-to-Left (RTL) languages automatically.

```jsx
<div dir="rtl" style={{ width: '100%' }}>
  <Table
    data={data}
    columns={columns}
    title="مخزون المنتجات"
    striped={true}
    gridCells={false}
  />
</div>
```

## Column Configuration

The Table component accepts columns defined according to TanStack Table's `ColumnDef` interface, with additional Tagaddod-specific properties for styling.

```jsx
const columns = [
  // Standard column with accessor and header
  {
    accessorKey: 'id',
    header: 'ID',
    size: 80,
  },
  
  // Column with custom cell rendering
  {
    accessorKey: 'status',
    header: 'Status',
    size: 150,
    cell: info => (
      <span 
        style={{ 
          color: 
            info.getValue() === 'Completed' ? 'var(--t-color-text-success)' :
            info.getValue() === 'Pending' ? 'var(--t-color-text-warning)' :
            'var(--t-color-text-info)'
        }}
      >
        {info.getValue()}
      </span>
    ),
  },
  
  // Column with custom styling via meta
  {
    id: 'actions',
    header: '',
    cell: () => (/* Action buttons */),
    meta: {
      headerClassName: 'custom-header',
      cellClassName: 'custom-cell',
      width: '100px',
    },
  },
];
```

## Advanced Usage

### Controlled Table

Full control of table state for advanced integration needs.

```jsx
const [sorting, setSorting] = useState([]);
const [globalFilter, setGlobalFilter] = useState('');
const [pagination, setPagination] = useState({
  pageIndex: 0,
  pageSize: 10,
});
const [filters, setFilters] = useState({});

<Table
  data={data}
  columns={columns}
  title="Advanced Table"
  searchQuery={globalFilter}
  onSearchChange={setGlobalFilter}
  pagination={{
    pageIndex: pagination.pageIndex,
    pageSize: pagination.pageSize,
    pageCount: Math.ceil(data.length / pagination.pageSize),
    onPageChange: (pageIndex) => setPagination(prev => ({ ...prev, pageIndex })),
    onPageSizeChange: (pageSize) => setPagination(prev => ({ ...prev, pageSize })),
  }}
  defaultSorting={sorting}
  activeFilters={filters}
  onFilterChange={setFilters}
/>
```

### Server-Side Data

For tables with server-side pagination, sorting, and filtering.

```jsx
const [data, setData] = useState([]);
const [totalItems, setTotalItems] = useState(0);
const [loading, setLoading] = useState(false);
const [pagination, setPagination] = useState({
  pageIndex: 0,
  pageSize: 10,
});
const [sorting, setSorting] = useState([]);
const [filters, setFilters] = useState({});

// Fetch data on state changes
useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await api.fetchData({
        page: pagination.pageIndex,
        limit: pagination.pageSize,
        sort: sorting.length > 0 ? { 
          field: sorting[0].id, 
          direction: sorting[0].desc ? 'desc' : 'asc' 
        } : undefined,
        filters,
      });
      
      setData(response.data);
      setTotalItems(response.total);
    } catch (error) {
      console.error('Error fetching data:', error);
    } finally {
      setLoading(false);
    }
  };
  
  fetchData();
}, [pagination, sorting, filters]);

<Table
  data={data}
  columns={columns}
  title="Server-Side Table"
  state={loading ? 'loading' : 'normal'}
  pagination={{
    pageIndex: pagination.pageIndex,
    pageSize: pagination.pageSize,
    pageCount: Math.ceil(totalItems / pagination.pageSize),
    onPageChange: (pageIndex) => setPagination(prev => ({ ...prev, pageIndex })),
    onPageSizeChange: (pageSize) => setPagination(prev => ({ ...prev, pageSize })),
  }}
  defaultSorting={sorting}
  activeFilters={filters}
  onFilterChange={setFilters}
/>
```

## Common Use Cases

### Data Grid with Row Actions

Table with row actions for data management operations.

```jsx
<Table
  data={users}
  columns={[
    { accessorKey: 'name', header: 'Name' },
    { accessorKey: 'email', header: 'Email' },
    { accessorKey: 'role', header: 'Role' },
    {
      id: 'actions',
      header: 'Actions',
      cell: ({ row }) => (
        <div style={{ display: 'flex', gap: '8px' }}>
          <Button
            variant="plain"
            size="micro"
            tone="neutral"
            prefixIcon={<IconEdit size={16} />}
            onClick={(e) => {
              e.stopPropagation();
              editUser(row.original);
            }}
          />
          <Button
            variant="plain"
            size="micro"
            tone="critical"
            prefixIcon={<IconTrash size={16} />}
            onClick={(e) => {
              e.stopPropagation();
              deleteUser(row.original.id);
            }}
          />
        </div>
      ),
    },
  ]}
  onRowClick={(row) => viewUserDetails(row.original.id)}
/>
```

### Dashboard Analytics Table

Display analytical data with metrics and visual indicators.

```jsx
<Table
  data={analyticsData}
  columns={[
    { accessorKey: 'metric', header: 'Metric' },
    { 
      accessorKey: 'value', 
      header: 'Value',
      cell: ({ row }) => formatNumber(row.original.value),
    },
    { 
      accessorKey: 'change', 
      header: 'Change',
      cell: ({ getValue }) => {
        const change = getValue();
        return (
          <div style={{ 
            color: change > 0 ? 'var(--t-color-text-success)' : 'var(--t-color-text-critical)',
            display: 'flex',
            alignItems: 'center',
            gap: '4px'
          }}>
            {change > 0 ? '↑' : '↓'} {Math.abs(change)}%
          </div>
        );
      },
    },
    { 
      id: 'chart',
      header: 'Trend',
      cell: ({ row }) => <SparklineChart data={row.original.trend} />,
    },
  ]}
  title="Performance Metrics"
  gridCells={true}
/>
```

### Record Selection Table

Table with row selection for batch operations.

```jsx
const [selectedRows, setSelectedRows] = useState([]);

// Define selection column
const selectionColumn = {
  id: 'selection',
  header: ({ table }) => (
    <input
      type="checkbox"
      checked={table.getIsAllRowsSelected()}
      onChange={table.getToggleAllRowsSelectedHandler()}
    />
  ),
  cell: ({ row }) => (
    <input
      type="checkbox"
      checked={row.getIsSelected()}
      onChange={row.getToggleSelectedHandler()}
      onClick={(e) => e.stopPropagation()}
    />
  ),
  size: 40,
};

// Columns with selection
const columnsWithSelection = [selectionColumn, ...columns];

<div>
  <div style={{ marginBottom: '16px' }}>
    <Button 
      disabled={selectedRows.length === 0}
      onClick={() => handleBatchAction(selectedRows)}
    >
      Process Selected ({selectedRows.length})
    </Button>
  </div>
  
  <Table
    data={data}
    columns={columnsWithSelection}
    title="Select Records"
    onRowSelectionChange={setSelectedRows}
  />
</div>
```

## Accessibility

The Table component is built with accessibility in mind:

- Semantic HTML table structure (`<table>`, `<thead>`, `<tbody>`, `<tr>`, `<th>`, `<td>`) for optimal screen reader compatibility
- Appropriate ARIA attributes for sorting, filtering, and pagination
- Keyboard navigation support for all interactive elements
- Focus management for row and cell interactions
- Proper contrast ratios for all visual states
- RTL language support with appropriate text alignment and directional changes
- Visible focus indicators for keyboard users
- Responsive design that works on various screen sizes and devices

## Implementation Details

### CSS Variables

The Table component uses the following token CSS variables:

| Variable | Purpose |
|----------|---------|
| `--t-space-*` | Padding and spacing |
| `--t-typography-body-sm-default` | Typography for text cell variants |
| `--t-font-family-primary` | Text font |
| `--t-font-size-*` | Font sizes for text elements |
| `--t-font-weight-*` | Font weights |
| `--t-color-text-primary` | Primary text color |
| `--t-color-text-secondary` | Secondary text color (multiline second lines) |
| `--t-color-text-tertiary` | Tertiary text color |
| `--t-color-border-*` | Border colors |
| `--t-color-surface-primary` | Table background color |
| `--t-color-surface-hover` | Row hover background color |
| `--t-color-surface-active` | Striped row hover background color |
| `--t-color-surface-secondary` | Header background color |
| `--t-color-fill-*` | Highlight colors |
| `--t-border-radius-*` | Border radius |
| `--t-shadow-*` | Box shadows |
| `--t-duration-*` | Animation duration |
| `--t-line-height-*` | Line height for different languages |

### Technical Architecture

The Table component is built on TanStack Table and includes:

- **Data Processing**: Core row model, filtering, sorting, and pagination
- **State Management**: Component-level React state with controlled inputs
- **Event Handling**: Row and cell click handlers
- **Keyboard Navigation**: Accessible keyboard controls
- **Rendering Optimization**: Efficient rendering with React memoization
- **Styling**: CSS Modules with proper scoping
- **Responsive Design**: Mobile-friendly layout and styling

### Performance Considerations

For optimal performance with large datasets:

- Use server-side pagination for tables with more than 1,000 rows
- Implement server-side sorting and filtering for tables with complex data structures
- Consider virtualization for extremely large datasets
- Optimize column rendering by minimizing complex cell renderers
- Use memoization for expensive cell calculations
- Enable the `manualPagination` option for custom data fetching

### Table Integration with Other Components

The Table component seamlessly integrates with other Tagaddod Design System components:

- **Pagination**: For page navigation
- **Tabs**: For tabbed data views
- **Button**: For action buttons
- **TextInput**: For search functionality
- **FilterItem**: For applying data filters
- **Badge**: For count indicators

## Browser Support

The Table component is compatible with all modern browsers:

- Chrome (latest)
- Firefox (latest)
- Safari (latest)
- Edge (latest)
- Mobile browsers (iOS Safari, Android Chrome)

RTL language support works across all supported browsers.

## Dependencies

The Table component's advanced features require these additional dependencies:

### Column Ordering & Resizing
- `@dnd-kit/core` - Modern drag and drop library for React
- `@dnd-kit/sortable` - Sortable utilities for column reordering
- `@dnd-kit/utilities` - Utility functions for drag and drop

These dependencies are automatically included when you install the Table component and provide:
- **Modern DnD**: React 18+ compatible drag and drop
- **Accessibility**: Full keyboard and screen reader support
- **Performance**: Optimized for smooth interactions
- **Touch Support**: Works on mobile and tablet devices

### Bundle Size Impact
The column management features add approximately 15-20KB to your bundle size. If you don't need these features, they can be tree-shaken out in future versions of the component library.
