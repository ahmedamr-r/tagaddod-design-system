#!/usr/bin/env node
/**
 * Consolidated Type Generation Utility
 * Handles building, copying, and generating TypeScript declaration files
 * for the Tagaddod Design System React components.
 */
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Paths
const distDir = path.resolve(__dirname, '../dist');
const componentsDir = path.resolve(__dirname, '../src/components');
const hooksDir = path.resolve(__dirname, '../src/hooks');
const providersDir = path.resolve(__dirname, '../src/providers');
const srcDir = path.resolve(__dirname, '../src');

/**
 * Ensures the dist directory exists
 */
function ensureDistDir() {
  if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, { recursive: true });
    console.log('‚úÖ Created dist directory');
  }
}

/**
 * Runs TypeScript to generate declaration files
 * @returns {boolean} Whether the TypeScript build succeeded
 */
function runTypescriptBuild() {
  try {
    console.log('üîÑ Running TypeScript to generate declarations...');
    execSync('tsc --project tsconfig.build.json', { stdio: 'inherit' });
    console.log('‚úÖ TypeScript declarations built successfully!');
    return true;
  } catch (error) {
    console.error('‚ùå Error building TypeScript declarations:', error.message);
    return false;
  }
}

/**
 * Scans source directories to build a component and types map
 * @returns {Object} Object containing component and types information
 */
function scanSourceDirectories() {
  console.log('üîç Scanning source directories...');
  
  const typesInfo = {
    components: [],
    hooks: [],
    providers: []
  };

  // Get component directories
  if (fs.existsSync(componentsDir)) {
    typesInfo.components = fs.readdirSync(componentsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => {
        const name = dirent.name;
        const indexPath = path.join(componentsDir, name, 'index.ts');
        const componentPath = path.join(componentsDir, name, `${name}.tsx`);
        const typesPath = path.join(componentsDir, name, 'types.ts');
        
        return {
          name,
          hasIndex: fs.existsSync(indexPath),
          hasComponent: fs.existsSync(componentPath),
          hasTypes: fs.existsSync(typesPath)
        };
      });
  }

  // Get hooks
  if (fs.existsSync(hooksDir)) {
    typesInfo.hooks = fs.readdirSync(hooksDir)
      .filter(file => file.endsWith('.ts') || file.endsWith('.tsx'))
      .map(file => file.replace(/\.(ts|tsx)$/, ''));
  }

  // Get providers
  if (fs.existsSync(providersDir)) {
    typesInfo.providers = fs.readdirSync(providersDir)
      .filter(file => file.endsWith('.ts') || file.endsWith('.tsx'))
      .map(file => file.replace(/\.(ts|tsx)$/, ''));
  }

  console.log(`‚úÖ Found ${typesInfo.components.length} components, ${typesInfo.hooks.length} hooks, and ${typesInfo.providers.length} providers`);
  return typesInfo;
}

/**
 * Generates a comprehensive index.d.ts file based on scanning source files
 * @param {Object} typesInfo Component and types information
 */
function generateIndexDeclaration(typesInfo) {
  console.log('üìù Generating index.d.ts...');
  
  let declarations = `// Type definitions for @tagaddod-design/react
// Generated by consolidated-types-utility.js

`;

  // Add components
  if (typesInfo.components.length > 0) {
    declarations += '// Component exports\n';
    typesInfo.components.forEach(component => {
      const { name, hasIndex } = component;
      if (hasIndex) {
        declarations += `export * from './components/${name}';\n`;
      } else {
        declarations += `export * from './components/${name}/${name}';\n`;
      }
    });
    declarations += '\n';
  }

  // Add hooks
  if (typesInfo.hooks.length > 0) {
    declarations += '// Hook exports\n';
    typesInfo.hooks.forEach(hook => {
      declarations += `export * from './hooks/${hook}';\n`;
    });
    declarations += '\n';
  }

  // Add providers
  if (typesInfo.providers.length > 0) {
    declarations += '// Provider exports\n';
    typesInfo.providers.forEach(provider => {
      declarations += `export * from './providers/${provider}';\n`;
    });
    declarations += '\n';
  }

  // Write the declarations file
  fs.writeFileSync(path.join(distDir, 'index.d.ts'), declarations);
  console.log('‚úÖ Generated index.d.ts');
}

/**
 * Creates a more precise index.d.ts based on the barrel exports
 * in src/index.ts (if available)
 */
function createPreciseDeclarations() {
  console.log('üîç Checking for src/index.ts to create precise declarations...');
  
  const indexPath = path.join(srcDir, 'index.ts');
  if (fs.existsSync(indexPath)) {
    try {
      const indexContent = fs.readFileSync(indexPath, 'utf8');
      let declarations = `// Type definitions for @tagaddod-design/react
// Generated based on src/index.ts

`;

      // Process the exports from index.ts
      const exportLines = indexContent.split('\n')
        .filter(line => line.trim().startsWith('export'))
        .map(line => line.trim());
      
      if (exportLines.length > 0) {
        declarations += exportLines.join('\n')
          .replace(/from '\.\//g, `from './`)
          .replace(/from '.\//g, `from './`)
          + '\n';
      }

      // Write the declarations file
      fs.writeFileSync(path.join(distDir, 'index.d.ts'), declarations);
      console.log('‚úÖ Created precise index.d.ts based on src/index.ts');
      return true;
    } catch (err) {
      console.error(`‚ùå Error processing src/index.ts:`, err.message);
      return false;
    }
  } else {
    console.log('‚ö†Ô∏è src/index.ts not found, will use generated declarations');
    return false;
  }
}

/**
 * Creates a component-level declaration files for better import support
 * @param {Object} typesInfo Component and types information
 */
function createComponentDeclarations(typesInfo) {
  console.log('üîÑ Creating component-level declaration files...');

  // Create components directory
  const componentsDistDir = path.resolve(distDir, 'components');
  if (!fs.existsSync(componentsDistDir)) {
    fs.mkdirSync(componentsDistDir, { recursive: true });
  }

  // Create a declaration file for each component
  typesInfo.components.forEach(component => {
    const componentDistDir = path.resolve(componentsDistDir, component.name);
    
    // Create component directory
    if (!fs.existsSync(componentDistDir)) {
      fs.mkdirSync(componentDistDir, { recursive: true });
    }
    
    // Create a d.ts file for the component
    const componentDtsContent = 
      `// Type definitions for ${component.name} component\n` +
      `export * from '../../index';\n`;
    
    fs.writeFileSync(
      path.resolve(componentDistDir, 'index.d.ts'), 
      componentDtsContent
    );
  });

  console.log('‚úÖ Created component-level declaration files');
}

/**
 * Creates a fallback index.d.ts file if all else fails
 * @param {Object} typesInfo Component and types information
 */
function createFallbackDeclarations(typesInfo) {
  console.log('üìù Creating fallback index.d.ts...');
  
  let declarations = `// Type definitions for @tagaddod-design/react
// Fallback declaration file

`;

  // Add components
  typesInfo.components.forEach(component => {
    declarations += `export * from './components/${component.name}/${component.name}';\n`;
  });

  // Add providers
  typesInfo.providers.forEach(provider => {
    declarations += `export * from './providers/${provider}';\n`;
  });

  // Add hooks
  typesInfo.hooks.forEach(hook => {
    declarations += `export * from './hooks/${hook}';\n`;
  });

  // Write the declarations file
  fs.writeFileSync(path.join(distDir, 'index.d.ts'), declarations);
  console.log('‚úÖ Created fallback index.d.ts');
}

/**
 * Main function to build types
 */
function buildTypes() {
  try {
    console.log('üöÄ Starting TypeScript declaration generation...');
    
    // Ensure dist directory exists
    ensureDistDir();
    
    // Scan the source directories
    const typesInfo = scanSourceDirectories();
    
    // Try running TypeScript build
    const tsBuildSuccess = runTypescriptBuild();
    
    // Check if index.d.ts was created by TypeScript
    if (tsBuildSuccess && fs.existsSync(path.join(distDir, 'index.d.ts'))) {
      console.log('‚úÖ TypeScript successfully generated index.d.ts');
    } else {
      console.log('‚ö†Ô∏è TypeScript failed to generate index.d.ts, creating manually...');
      
      // Try creating precise declarations from src/index.ts
      const preciseDeclCreated = createPreciseDeclarations();
      
      // If precise declarations didn't work, generate from scan
      if (!preciseDeclCreated) {
        generateIndexDeclaration(typesInfo);
      }
    }
    
    // Create component-level declarations for better import support
    createComponentDeclarations(typesInfo);
    
    console.log('‚ú® Type declaration generation complete!');
  } catch (error) {
    console.error('‚ùå Error during type generation:', error);
    
    // Final fallback - create a minimal declaration if all else fails
    try {
      const typesInfo = scanSourceDirectories();
      createFallbackDeclarations(typesInfo);
    } catch (fallbackError) {
      console.error('üí• Critical error, could not create fallback declarations:', fallbackError);
      process.exit(1);
    }
  }
}

// Run the build types process
buildTypes();
